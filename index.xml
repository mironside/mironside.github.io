<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mironside</title>
    <link>http://mironside.com/</link>
    <description>Recent content on mironside</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Dec 2015 22:29:27 -0600</lastBuildDate>
    <atom:link href="http://mironside.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>C&#43;&#43;11 Compile-Time String Hashing</title>
      <link>http://mironside.com/post/2015-12-14-compile-time-string-hashing/</link>
      <pubDate>Mon, 14 Dec 2015 22:29:27 -0600</pubDate>
      
      <guid>http://mironside.com/post/2015-12-14-compile-time-string-hashing/</guid>
      <description>&lt;p&gt;Here is a simple, lightweight implementation of compile-time string hashing in C++11.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll use the DJB hash function for simplicity.  This function can be called at runtime to hash a string literal.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; djb(&lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;char&lt;/span&gt; *str)
{
    &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; value = 5381;

    &lt;span style=&#34;color: #0000ff&#34;&gt;while&lt;/span&gt; (*str)
        value = value * 33 + *str++;

    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; value;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In C++11, &lt;code&gt;constexpr&lt;/code&gt; can be used to denote that a function can be evaluated at compile time.  But &lt;code&gt;constexpr&lt;/code&gt; also has certain constraints which disallow looping and multiple return statements.  hash can be rewritten as a recursive function to satisfy these &lt;code&gt;constexpr&lt;/code&gt; constraints.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; djb(&lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;char&lt;/span&gt; *str, &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; value=5381)
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; *str == 0 ? value : djb(str + 1, value * 33 + *str);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now the constexpr hash function can be called to hash a string literal.  This does not guaruntee it is evaluated at compile-time.  In fact, assembly output shows the constexpr still generates a runtime function call.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; sid = djb(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;this is a string test!&amp;quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;    mov edx, 5381               &lt;span style=&#34;color: #008000&#34;&gt;; 00001505H&lt;/span&gt;
    lea rcx, OFFSET FLAT:&lt;span style=&#34;color: #0000ff&#34;&gt;$&lt;/span&gt;SG63574
    call    ?djb@@YAIPEBDI@Z            &lt;span style=&#34;color: #008000&#34;&gt;; djb&lt;/span&gt;
    mov &lt;span style=&#34;color: #2b91af&#34;&gt;DWORD&lt;/span&gt; PTR sid$[rsp], eax
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;To force the constexpr to be evaluated at compile-time it needs to be called from a compile-time only context.  One solution is to use the constexpr function call as a template parameter.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; v&amp;gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; const_value {
    &lt;span style=&#34;color: #0000ff&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; value = v;
};

&lt;span style=&#34;color: #0000ff&#34;&gt;#define DJB(x) const_value&amp;lt;djb(x)&amp;gt;::value&lt;/span&gt;

&lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; id = DJB(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;this is a string test!&amp;quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;    mov &lt;span style=&#34;color: #2b91af&#34;&gt;DWORD&lt;/span&gt; PTR id$[rsp], 1910223762      &lt;span style=&#34;color: #008000&#34;&gt;; 71dbb392H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;The hash function is evaluated at compile-time leaving only the hashed value compiled into the executable.&lt;/p&gt;

&lt;p&gt;The compile-time hash construct works with any hash function that fits within the constraints of &lt;code&gt;constexpr&lt;/code&gt;.  Below is the full code for both DJB and CRC32 compile-time hashes.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#include &amp;lt;stdint.h&amp;gt;&lt;/span&gt;

constexpr &lt;span style=&#34;color: #0000ff&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; crc32_table[] = {
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
    0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
    0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
    0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
    0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
    0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
    0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
    0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
    0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
    0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
    0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
    0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
    0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
    0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
    0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
    0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
    0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
    0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
    0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
    0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
    0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
    0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
    0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
    0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
    0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
    0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
    0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
    0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
    0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
    0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
    0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
    0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
    0x2d02ef8d
};

constexpr &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; crc32(&lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;char&lt;/span&gt; *str, &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; crc=0xffffffff)
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; *str == 0 ? 
            crc ^ 0xffffffff :
            crc32(str + 1, crc32_table[(crc ^ *str) &amp;amp; 0xFF] ^ (crc &amp;gt;&amp;gt; 8));
}

constexpr &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; djb(&lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;char&lt;/span&gt; *str, &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; value=5381)
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; *str == 0 ?
            value :
            djb(str + 1, value * 33 + *str);
}

template&amp;lt;&lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; v&amp;gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; const_value {
    &lt;span style=&#34;color: #0000ff&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; value = v;
};

&lt;span style=&#34;color: #0000ff&#34;&gt;#define DJB(STRING) const_value&amp;lt;djb(STRING)&amp;gt;::value&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define CRC32(STRING) const_value&amp;lt;crc32(STRING)&amp;gt;::value&lt;/span&gt;


&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color: #2b91af&#34;&gt;char&lt;/span&gt; **argv)
{
    &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; id = DJB(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;this is a string test!&amp;quot;&lt;/span&gt;);
    &lt;span style=&#34;color: #2b91af&#34;&gt;uint32_t&lt;/span&gt; crc = CRC32(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;this is a string test!&amp;quot;&lt;/span&gt;);
    printf(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;djb:   %u\ncrc32: %u\n&amp;quot;&lt;/span&gt;, id, crc);

    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C API Internal Access Protection</title>
      <link>http://mironside.com/post/2015-09-23-c-api-internal-access-protection/</link>
      <pubDate>Wed, 23 Sep 2015 00:00:00 -0600</pubDate>
      
      <guid>http://mironside.com/post/2015-09-23-c-api-internal-access-protection/</guid>
      <description>

&lt;p&gt;I like C style apis, they&amp;rsquo;re simple and clean.  When I create an api I use an underscored prefix to group functions in the same api.&lt;/p&gt;

&lt;h3 id=&#34;c-time-api:d40493909dc16965ed33df035bd64be1&#34;&gt;C Time API&lt;/h3&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #2b91af&#34;&gt;uint64_t&lt;/span&gt; Time_GetTicks();
&lt;span style=&#34;color: #2b91af&#34;&gt;uint64_t&lt;/span&gt; Time_GetTickFrequency();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the source file I group api data in a static struct instance named with the same prefix.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Time_ {
	LARGE_INTEGER timeStart;
	LARGE_INTEGER timeFrequency;
} Time_;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The struct type is declared with the same name as the instance so statics and type declarations can be accessed through the same Time_:: namespace.  In fact, any use of the Time api starts with the same prefix:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Time_::type&lt;/li&gt;
&lt;li&gt;Time_.member&lt;/li&gt;
&lt;li&gt;Time_Function()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This allows trivial api renaming with a simple find and replace of &amp;ldquo;Time_&amp;rdquo;.  The underscored name also avoids conflicting with any user facing typename that might be returned by the api.  A File_ api might want to return a File pointer for example.&lt;/p&gt;

&lt;p&gt;Inside the api functions the struct is always used explicitly.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Time_Initialize()
{
	QueryPerformanceCounter(&amp;amp;Time_.timeStart);
	QueryPerformanceFrequency(&amp;amp;Time_.timeFrequency);
}

&lt;span style=&#34;color: #2b91af&#34;&gt;uint64_t&lt;/span&gt; Time_GetTicks()
{
	LARGE_INTEGER now;
	QueryPerformanceCounter(&amp;amp;now);
	&lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; now.QuadPart - Time_.timeStart.QuadPart;
}

&lt;span style=&#34;color: #2b91af&#34;&gt;uint64_t&lt;/span&gt; Time_GetTickFrequency()
{
	&lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; Time_.timeFrequency.QuadPart;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This organization is clean and simple and the data is hidden inside the translation unit.  Pretty good, but it would be nice to protect the api data from being used outside the api functions inside the same translation unit.  This is especially handy for unity builds where everything is in the same translation unit.&lt;/p&gt;

&lt;p&gt;The adjustment is simple: 1) make members private 2) make api functions friends&lt;/p&gt;

&lt;p&gt;I prefer to use a class instead of a struct so members default to private without the noise of an extra private: statement.  Friend declarations simply follow the data declarations in the class.  This has a nice effect of grouping everything in the api but with the downside of needing to redeclare the functions an extra time as friends.&lt;/p&gt;

&lt;h3 id=&#34;access-protection:d40493909dc16965ed33df035bd64be1&#34;&gt;Access Protection&lt;/h3&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;static&lt;/span&gt; class Time_ {
	LARGE_INTEGER timeStart;
	LARGE_INTEGER timeFrequency;

	friend &lt;span style=&#34;color: #0000ff&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Time_Initialize();
	friend &lt;span style=&#34;color: #2b91af&#34;&gt;uint64_t&lt;/span&gt; Time_GetTicks();
	friend &lt;span style=&#34;color: #2b91af&#34;&gt;uint64_t&lt;/span&gt; Time_GetTickFrequency();
} Time_;

&lt;span style=&#34;color: #0000ff&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Time_Initialize()
{
	QueryPerformanceCounter(&amp;amp;Time_.timeStart);
	QueryPerformanceFrequency(&amp;amp;Time_.timeFrequency);
}

&lt;span style=&#34;color: #2b91af&#34;&gt;uint64_t&lt;/span&gt; Time_GetTicks()
{
	LARGE_INTEGER now;
	QueryPerformanceCounter(&amp;amp;now);
	&lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; now.QuadPart - Time_.timeStart.QuadPart;
}

&lt;span style=&#34;color: #2b91af&#34;&gt;uint64_t&lt;/span&gt; Time_GetTickFrequency()
{
	&lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; Time_.timeFrequency.QuadPart;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;The best part is that this has no effect on the organization of the rest of the C code.  You can add or remove data protection simply by changing the struct declaration.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Considerations of a Bag Data Structure</title>
      <link>http://mironside.com/post/2015-06-08-set-data-structure/</link>
      <pubDate>Mon, 08 Jun 2015 00:00:00 -0600</pubDate>
      
      <guid>http://mironside.com/post/2015-06-08-set-data-structure/</guid>
      <description>

&lt;p&gt;I wanted to write a post about the details considered when implementing a simple data structure in the C style (ie. C with a tiny bit of C++).  Here goes&amp;hellip;&lt;/p&gt;

&lt;p&gt;A Bag data structure stores a collection of unordered, non-unique items.  It differs from an Array (which stores ordered, non-unique items) and a Set (which stores unordered, unique items).  A Bag can be used in place of an Array where the order of the collection is not important.  For instance, a graph node&amp;rsquo;s children have no specific order and could be stored in a Bag.&lt;/p&gt;

&lt;p&gt;A Bag performs the same as an Array except that the remove operation is constant and may change item order.  Removing the 0th element of a 1,000,000 item Array causes 999,999 items be moved.  A Bag, on the other hand, simply removes the 0th item by moving the 999,999th item into the 0th index.&lt;/p&gt;

&lt;p&gt;Here is a simple unstructured Bag implementation using an array.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000&#34;&gt;// bag implementation over an array&lt;/span&gt;
&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; count = 0;
&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; items[10];

&lt;span style=&#34;color: #008000&#34;&gt;// add items&lt;/span&gt;
items[count++] = 1;
items[count++] = 3;
items[count++] = 5;
items[count++] = 7;
&lt;span style=&#34;color: #0000ff&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++)
    printf(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;%d &amp;quot;&lt;/span&gt;, items[i]);
&lt;span style=&#34;color: #008000&#34;&gt;// 1 3 5 7&lt;/span&gt;

&lt;span style=&#34;color: #008000&#34;&gt;// remove item 1&lt;/span&gt;
items[1] = items[--count];
&lt;span style=&#34;color: #0000ff&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++)
    printf(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;%d &amp;quot;&lt;/span&gt;, items[i]);
&lt;span style=&#34;color: #008000&#34;&gt;// 1 7 5&lt;/span&gt;

&lt;span style=&#34;color: #008000&#34;&gt;// remove item 0&lt;/span&gt;
items[0] = items[--count];
&lt;span style=&#34;color: #0000ff&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++)
    printf(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;%d &amp;quot;&lt;/span&gt;, items[i]);
&lt;span style=&#34;color: #008000&#34;&gt;// 5 7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The logic for the Bag is very simple but prone to error when used manuaully.  It is prudent to create a struct and set of functions to simplify using a Bag.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Bag {
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; count;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; items[10];
};

&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Bag_Init(Bag *s)
{
    s-&amp;gt;count = 0;
}

&lt;span style=&#34;color: #2b91af&#34;&gt;bool&lt;/span&gt; Bag_Add(Bag *s, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; value)
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (s-&amp;gt;count + 1 &amp;gt; &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(s-&amp;gt;items) / &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(s-&amp;gt;items[0])) {
        &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; false;
    }

    s-&amp;gt;items[s-&amp;gt;count++] = value;
    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; true;
}

&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Bag_Remove(Bag *s, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; index)
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; s-&amp;gt;count) {
        s-&amp;gt;items[index] = s-&amp;gt;items[--s-&amp;gt;count];
    }
}


Bag s;

Bag_Init(&amp;amp;s);

&lt;span style=&#34;color: #008000&#34;&gt;// add items&lt;/span&gt;
Bag_Add(&amp;amp;s, 1);
Bag_Add(&amp;amp;s, 3);
Bag_Add(&amp;amp;s, 5);
Bag_Add(&amp;amp;s, 7);
&lt;span style=&#34;color: #0000ff&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; s.count; i++)
    printf(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;%d &amp;quot;&lt;/span&gt;, s.items[i]);
&lt;span style=&#34;color: #008000&#34;&gt;// 1 3 5 7&lt;/span&gt;

&lt;span style=&#34;color: #008000&#34;&gt;// remove item 1&lt;/span&gt;
Bag_Remove(&amp;amp;s, 1);
&lt;span style=&#34;color: #0000ff&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; s.count; i++)
    printf(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;%d &amp;quot;&lt;/span&gt;, s.items[i]);
&lt;span style=&#34;color: #008000&#34;&gt;// 1 7 5&lt;/span&gt;

&lt;span style=&#34;color: #008000&#34;&gt;// remove item 0&lt;/span&gt;
Bag_Remove(&amp;amp;s, 0);
&lt;span style=&#34;color: #0000ff&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; s.count; i++)
    printf(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;%d &amp;quot;&lt;/span&gt;, s.items[i]);
&lt;span style=&#34;color: #008000&#34;&gt;// 5 7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The size of the bag is fixed at 10, if we add an 11th item it is discarded and lost.  Obviously we want to be able to specify how many items to store.&lt;/p&gt;

&lt;p&gt;One option is to statically declare the array size using a template parameter.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;template&amp;lt;&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; N&amp;gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Bag {
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; capacity;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; count;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; items[N];
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;This is useful for static sized Bags and declaring temporary Bag variables on the stack.  A downside is that the number of items is part of the type, it has to be passed as that specific type.  A Bag&lt;10&gt; cannot be used in place of a Bag&lt;20&gt;, and neither can be passed to a function.  There are ways around this using templates but that becomes more complicated than I&amp;rsquo;d like.&lt;/p&gt;

&lt;p&gt;The other option is to have the Bag dynamically allocate the item memory for us.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Bag {
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; capacity;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; count;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; *items;
};

&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Bag_Init(Bag *s, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; capacity)
{
    s-&amp;gt;capacity = capacity;
    s-&amp;gt;count = 0;
    s-&amp;gt;items = (&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; *)malloc(&lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt;) * capacity);
}

&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Bag_Free(Bag *s)
{
    free(s-&amp;gt;items);
}

Bag s;
Bag_Init(&amp;amp;s, 10);
...
Bag_Free(&amp;amp;s);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;This is convenient, but the user has no control over the allocation.  The Bag could take custom alloc/free hooks in Bag_Init.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Bag {
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; capacity;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; count;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; *items;
    &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *(*malloc)(&lt;span style=&#34;color: #2b91af&#34;&gt;size_t&lt;/span&gt;);
    &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; (*free)(&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *);
    &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *userdata;
};


&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Bag_Init(Bag *s, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; capacity, &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *(*customMalloc)(&lt;span style=&#34;color: #2b91af&#34;&gt;size_t&lt;/span&gt;, &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *userdata), &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; (*customFree)(&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *, &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *userdata), &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *userdata)
{
    s-&amp;gt;malloc = malloc;
    s-&amp;gt;free = free;
    &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (customMalloc) {
        s-&amp;gt;malloc = customMalloc;
    }
    &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (customFree) {
        s-&amp;gt;free = customFree;
    }
    s-&amp;gt;userdata = userdata;

    s-&amp;gt;capacity = capacity;
    s-&amp;gt;count = 0;
    s-&amp;gt;items = (&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; *)s-&amp;gt;malloc(&lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt;) * capacity, s-&amp;gt;userdata);
}

&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Bag_Free(Bag *s)
{
    s-&amp;gt;free(s-&amp;gt;items, s-&amp;gt;userdata);
}


&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Buffer {
    &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *data;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; used;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; capacity;
};

&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *myAlloc(&lt;span style=&#34;color: #2b91af&#34;&gt;size_t&lt;/span&gt; size, &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *userdata)
{
    Buffer *b = (Buffer *)userdata;
    &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *mem = (byte *)b-&amp;gt;data + b-&amp;gt;used;
    b-&amp;gt;used += size;
    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; mem;
}

&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; myFree(&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *p)
{
    &lt;span style=&#34;color: #008000&#34;&gt;// don&amp;#39;t need to free stack memory&lt;/span&gt;
}

byte memory[1024];
Buffer b = {memory, 0, &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(memory)};

Bag s;
Bag_Init(&amp;amp;s, 10, myAlloc, myFree, &amp;amp;b);
...
Bag_Free(&amp;amp;s);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;So this is better, right?  The Bag is encapsulated and can manage itself, great!  But it takes a lot of work just to tell the Bag where to allocate memory, which makes using the Bag very inconvenient.  This is supposed to be a lightweight data structure!&lt;/p&gt;

&lt;p&gt;An alternative is to &lt;em&gt;give&lt;/em&gt; Bag the items to work on.  This allows the user to control the items allocation and the Bag only handles the logic.  The Bag can use stack, heap or custom memory trivially.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Bag {
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; capacity;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; count;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; *items;
};

&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Bag_Init(Bag *s, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; *items, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; capacity)
{
    s-&amp;gt;capacity = capacity;
    s-&amp;gt;count = 0;
    s-&amp;gt;items = items;
}

&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; items[10];
Bag s;
Bag_Init(&amp;amp;s, items, 10);
...

&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; *items = CustomAlloc(&lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt;) * 10);
Bag s;
Bag_Init(&amp;amp;s, items, 10);
...
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;In this example, the Bag acts as an overlay on the items array.  But now the Bag is two discontiguous chunks of memory: the Bag structure and the items array.  Moving, copying or reallocating the Bag is a multistep process: 1) copy the Bag struct  2) alloc a new items array  3) copy the old items into the new array  4) assign the new items to the new Bag&amp;rsquo;s items.&lt;/p&gt;

&lt;p&gt;We could allocate the Bag and items as a contiguous block of memory.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Bag {
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; capacity;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; count;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; items[];
};

&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Bag_Init(Bag *s, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; bytes)
{
    s-&amp;gt;capacity = (bytes - &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(Bag)) / &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt;);
    s-&amp;gt;count = 0;
}

byte memory[1024];
Bag *s = (Bag *)memory;
Bag_Init(&amp;amp;s, 1024);
...

Bag *s = (Bag *)malloc(1024);
Bag_Init(&amp;amp;s, 1024);
...
&lt;span style=&#34;color: #008000&#34;&gt;// out of space!&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt;(!Bag_Add(&amp;amp;s, i)) {
    s = (Bag *)realloc(s, 2048);
    Bag_Add(&amp;amp;s, i);
}
free(s);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Now the Bag can be trivially memcpy&amp;rsquo;d and realloc&amp;rsquo;d as a single block of data and is always internally consistent.  But there is also a downside to this approach.  Realloc&amp;rsquo;ing the Bag can return a different pointer invalidating existing references to the Bag.  With an internal items pointer realloc&amp;rsquo;ing the items inside the Bag won&amp;rsquo;t break other references to the Bag.&lt;/p&gt;

&lt;p&gt;Finally, the Bag isn&amp;rsquo;t very useful if it only works with ints.  A template can be used to parameterize the type of the items array.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;template&amp;lt;&lt;span style=&#34;color: #0000ff&#34;&gt;typename&lt;/span&gt; T&amp;gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Bag {
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; capacity;
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; count;
    T items[];
};

template&amp;lt;&lt;span style=&#34;color: #0000ff&#34;&gt;typename&lt;/span&gt; T&amp;gt;
&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Bag_Init(Bag&amp;lt;T&amp;gt; *s, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; bytes)
{
    s-&amp;gt;capacity = (bytes - &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(Bag&amp;lt;T&amp;gt;)) / &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(T);
    s-&amp;gt;count = 0;
}

template&amp;lt;&lt;span style=&#34;color: #0000ff&#34;&gt;typename&lt;/span&gt; T&amp;gt;
&lt;span style=&#34;color: #2b91af&#34;&gt;bool&lt;/span&gt; Bag_Add(Bag&amp;lt;T&amp;gt; *s, T value)
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (s-&amp;gt;count + 1 &amp;gt; s-&amp;gt;capacity) {
        &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; false;
    }

    s-&amp;gt;items[s-&amp;gt;count++] = value;
    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; true;
}

template&amp;lt;&lt;span style=&#34;color: #0000ff&#34;&gt;typename&lt;/span&gt; T&amp;gt;
&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Bag_Remove(Bag&amp;lt;T&amp;gt; *s, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; index)
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; s-&amp;gt;count) {
        s-&amp;gt;count--;
        s-&amp;gt;items[index] = s-&amp;gt;items[s-&amp;gt;count];
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;That is the whole Bag implementation: one struct and three simple functions.&lt;/p&gt;

&lt;p&gt;One last note, I prefer not to obscure data structures behind accessor functions.  In this case, I am not creating Bag_Count, Bag_Get, Bag_Set accessors because they can be accessed directly on the structure itself.&lt;/p&gt;

&lt;h2 id=&#34;the-bag:792802c592a1fbef33a7ae4e1d40beb6&#34;&gt;The Bag&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Does not manage it&amp;rsquo;s own memory, can easily be used with any user memory&lt;/li&gt;
&lt;li&gt;Can be relocated, copied or reallocated as a single memory block&lt;/li&gt;
&lt;li&gt;Adding and removing items is one value copy and one addition&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Niklas Frykholm uses this style of linear allocation and calculating pointer offsets in his nflibs string table implementation.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/niklasfrykholm/nflibs/blob/master/nf_string_table.c&#34;&gt;https://github.com/niklasfrykholm/nflibs/blob/master/nf_string_table.c&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build System in Go</title>
      <link>http://mironside.com/post/2015-05-06-golang-task-package/</link>
      <pubDate>Wed, 06 May 2015 00:00:00 -0600</pubDate>
      
      <guid>http://mironside.com/post/2015-05-06-golang-task-package/</guid>
      <description>&lt;p&gt;I wrote a golang package called tiny/task which implements the ideas of the task based build system described in a &lt;a href=&#34;{% post_url 2015-05-01-notes-on-task-based-build-system %}&#34;&gt;previous post&lt;/a&gt;.  Here is the tiny/task godoc:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;type&lt;/span&gt; Line &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; {
    Name &lt;span style=&#34;color: #2b91af&#34;&gt;string&lt;/span&gt;
    Data &lt;span style=&#34;color: #0000ff&#34;&gt;interface&lt;/span&gt;{}
}

&lt;span style=&#34;color: #0000ff&#34;&gt;type&lt;/span&gt; Task &lt;span style=&#34;color: #0000ff&#34;&gt;interface&lt;/span&gt; {
    Parse(line &lt;span style=&#34;color: #0000ff&#34;&gt;interface&lt;/span&gt;{}) ([]&lt;span style=&#34;color: #2b91af&#34;&gt;string&lt;/span&gt;, []&lt;span style=&#34;color: #2b91af&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color: #2b91af&#34;&gt;error&lt;/span&gt;)
    Execute(line &lt;span style=&#34;color: #0000ff&#34;&gt;interface&lt;/span&gt;{}) ([]Line, &lt;span style=&#34;color: #2b91af&#34;&gt;error&lt;/span&gt;)
}

&lt;span style=&#34;color: #0000ff&#34;&gt;func&lt;/span&gt; Register(name &lt;span style=&#34;color: #2b91af&#34;&gt;string&lt;/span&gt;, task Task)
&lt;span style=&#34;color: #0000ff&#34;&gt;func&lt;/span&gt; Execute(tasklines []Line) &lt;span style=&#34;color: #2b91af&#34;&gt;error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With tiny/task it is very easy to define your own tasks, schedule and execute them.  Internally tiny/task handles crc&amp;rsquo;ing input/output files to detect file changes.  It also discovers file dependencies between tasks and ensures that tasks execute in the correct order.&lt;/p&gt;

&lt;p&gt;Here is a simple program that declares a compile task and schedules a task to compile main.c to main.obj.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;package&lt;/span&gt; main

&lt;span style=&#34;color: #0000ff&#34;&gt;import&lt;/span&gt; (
	&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;os/exec&amp;quot;&lt;/span&gt;
	&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;tiny/task&amp;quot;&lt;/span&gt;
)

&lt;span style=&#34;color: #0000ff&#34;&gt;type&lt;/span&gt; CompileData &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; {
	SourceFile &lt;span style=&#34;color: #2b91af&#34;&gt;string&lt;/span&gt;
	ObjectFile &lt;span style=&#34;color: #2b91af&#34;&gt;string&lt;/span&gt;
}

&lt;span style=&#34;color: #0000ff&#34;&gt;type&lt;/span&gt; CompileTask &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt;{}

&lt;span style=&#34;color: #0000ff&#34;&gt;func&lt;/span&gt; (*CompileTask) Parse(line &lt;span style=&#34;color: #0000ff&#34;&gt;interface&lt;/span&gt;{}) ([]&lt;span style=&#34;color: #2b91af&#34;&gt;string&lt;/span&gt;, []&lt;span style=&#34;color: #2b91af&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color: #2b91af&#34;&gt;error&lt;/span&gt;) {
	d := line.(CompileData)
	&lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; []&lt;span style=&#34;color: #2b91af&#34;&gt;string&lt;/span&gt;{d.SourceFile}, []&lt;span style=&#34;color: #2b91af&#34;&gt;string&lt;/span&gt;{d.ObjectFile}, &lt;span style=&#34;color: #0000ff&#34;&gt;nil&lt;/span&gt;
}

&lt;span style=&#34;color: #0000ff&#34;&gt;func&lt;/span&gt; (*CompileTask) Execute(line &lt;span style=&#34;color: #0000ff&#34;&gt;interface&lt;/span&gt;{}) ([]task.Line, &lt;span style=&#34;color: #2b91af&#34;&gt;error&lt;/span&gt;) {
	d := line.(CompileData)
	cmd := exec.Command(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;cl.exe&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;-Tp&amp;quot;&lt;/span&gt;, d.SourceFile, &lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;-Fo&amp;quot;&lt;/span&gt;, d.ObjectFile)
	err := cmd.Run()
	&lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;nil&lt;/span&gt;, err
}

&lt;span style=&#34;color: #0000ff&#34;&gt;func&lt;/span&gt; main() {
	task.Register(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;compile&amp;quot;&lt;/span&gt;, new(CompileTask))
	taskline := task.Line{&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;compile&amp;quot;&lt;/span&gt;, CompileData{&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;main.c&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;main.obj&amp;quot;&lt;/span&gt;}}
	task.Execute([]task.Line{taskline})
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Notes on a Task Based Build System</title>
      <link>http://mironside.com/post/2015-05-01-notes-on-task-based-build-system/</link>
      <pubDate>Fri, 01 May 2015 00:00:00 -0600</pubDate>
      
      <guid>http://mironside.com/post/2015-05-01-notes-on-task-based-build-system/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Line&lt;/strong&gt; - Tasks are defined by Lines which declare the Task name and Task-specific data.  Information can only be passed between Tasks through Lines.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;File&lt;/strong&gt; - Represents a physical file on disk that may be an Input or an Output of a Task.  A File can have a list of File Dependencies, forming a tree.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FindDependencies&lt;/strong&gt; - A File may have an associated function to find it&amp;rsquo;s dependencies.  For instance, a .c File would have a function to find Files it #includes.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Task&lt;/strong&gt; - A Task consists of it&amp;rsquo;s opaque data object and Parse and Execute functions which perform the actual logic of the Task.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Parse&lt;/strong&gt; - Parses the task data object and returns the list of Input and Output Files.  Parse cannot read Input Files, it only translates the task-specific data into general inputs and outputs used for scheduling.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;HasChanges&lt;/strong&gt; - Determines if any Input, Input Dependencies or Output Files have changed.  If there are no changes the Task does not need to Execute.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Execute&lt;/strong&gt; - Processes the task using the Task data object: reads Input Files and creates Output Files.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;MetaTask&lt;/strong&gt; - Have the same capabilities as a Task but can create new Task Lines that get added to Scheduler when Executed.  Because they create Tasks MetaTasks always Execute.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Task dependencies are implicit based on Input and Output Files.  If Task B uses the File &amp;ldquo;main.obj&amp;rdquo; as Input and Task A outputs &amp;ldquo;main.obj&amp;rdquo; then Task B depends on Task A.  In other words, Task A must complete before Task B can Execute.  The Task Scheduler will only Execute Tasks that have no dependencies or whose dependencies have completed.  When a Task completes the Scheduler re-evaluates to see if any new Tasks can Execute.  This repeats until all Tasks are complete.&lt;/p&gt;

&lt;h2 id=&#34;example:ab3a8221151751c3ca2627c5aea0bb94&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s say we want to use this task system to build a program.  We want to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Read a project file to find C source files and target&lt;/li&gt;
&lt;li&gt;Compile all the C source files to obj files&lt;/li&gt;
&lt;li&gt;Link the obj files into an executable&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;First is the project Task Line:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;[project, {ProjectFile: myprogram.project}]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This declares the project Task and it&amp;rsquo;s data.  The Task system calls Parse on the data object producing a list of input and output files.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;project
    Input: myprogram.project
    Output:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The project Parse did not produce any Output files so it is considered a MetaTask and must Execute.&lt;/p&gt;

&lt;p&gt;The project Task Executes reading myprogram.project and finds that the target is game.exe and there are three source files: main.c, game.c and input.c.  It creates three compile Task Lines and one link Task Line which are added to the Task queue.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;[compile, {SourceFile: main.c, ObjectFile: main.obj}]
[compile, {SourceFile: game.c, ObjectFile: game.obj}]
[compile, {SourceFile: input.c, ObjectFile: input.obj}]
[link, {ObjectFiles: [main.obj, game.obj, input.obj], Executable: game.exe}]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;These new Tasks are Parsed to determine the Inputs and Outputs from their Task data object.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;compile
    Inputs: main.c
    Outputs: main.obj

compile
    Inputs: game.c
    Outputs: game.obj

compile
    Inputs: input.c
    Outputs: input.obj

link
    Inputs: [main.obj, game.obj, input.obj]
    Outputs: game.exe
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The link Task uses the files main.obj, game.obj and input.obj as Inputs which are also the Outputs of the compile Tasks.  Therefore the link Task is implicitly dependent on all three compile Tasks and cannot be run until they complete.  The three compile Tasks do not depend on any other Tasks so they are each Executed.  Since they don&amp;rsquo;t depend on each other they could even Execute in parallel.&lt;/p&gt;

&lt;p&gt;Using main.c as the example, FindDependencies runs and discovers that main.c #includes main.h and game.h (which #includes input.h), these are added as File dependencies.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;compile
    Inputs: main.c -&amp;gt; [main.h [game.h -&amp;gt; input.h]]
    Outputs: main.obj
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;The Task is checked for changes.  Inputs main.c main.h game.h and Output main.obj are all unchanged since the last build.  However, the dependency input.h has changed so the Task is Executed compiling main.c into main.obj.&lt;/p&gt;

&lt;p&gt;All three compile Tasks complete and the link Task now has no dependencies.  The Output game.exe matches the previous build but main.obj has changed since it was just re-compiled.  The link Task Executes linking the three object file Inputs into the game.exe Output file.&lt;/p&gt;

&lt;p&gt;With no more tasks in the queue, the build is complete.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Blizzard Build System</title>
      <link>http://mironside.com/post/2015-04-22-blizzard-build-system/</link>
      <pubDate>Wed, 22 Apr 2015 00:00:00 -0600</pubDate>
      
      <guid>http://mironside.com/post/2015-04-22-blizzard-build-system/</guid>
      <description>&lt;p&gt;A talk about the build system used by Blizzard.  They use it to build code but it seems like a nice architecture for building assets.&lt;/p&gt;

&lt;p&gt;Video: &lt;a href=&#34;http://www.gdcvault.com/play/1018139/Under-the-Hood-of-Blizzard&#34;&gt;http://www.gdcvault.com/play/1018139/Under-the-Hood-of-Blizzard&lt;/a&gt;
Slides: &lt;a href=&#34;http://www.gdcvault.com/play/1017943/Under-the-Hood-of-Blizzard&#34;&gt;http://www.gdcvault.com/play/1017943/Under-the-Hood-of-Blizzard&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>